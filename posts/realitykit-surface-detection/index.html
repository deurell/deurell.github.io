<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Realitykit Surface Detection | Deurell Labs</title>



<link href="https://deurell.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Deurell Labs">

<link rel="stylesheet" href="/css/style.css">

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="https://deurell.github.io/posts/realitykit-surface-detection/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>

<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="https://deurell.github.io">
          <h1 id="nav-heading" class="title is-4">Deurell Labs</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="twitter" href='https://twitter.com/deurell'
            target='_blank' rel='me noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg>
</i>
            </span>
          </a><a class="level-item" aria-label="github" href='https://github.com/deurell'
            target='_blank' rel='me noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg>
</i>
            </span>
          </a><a class="level-item" aria-label="email" href='mailto:dev@deurell.net'
            target='_blank' rel='me noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
    
  </svg>
</i>
            </span>
          </a><a class="level-item" aria-label="linkedin" href='https://linkedin.com/in/deurell'
            target='_blank' rel='me noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path stroke-width="1.8" d="m5.839218,4.101561c0,1.211972 -0.974141,2.194011 -2.176459,2.194011s-2.176459,-0.982039 -2.176459,-2.194011c0,-1.211094 0.974141,-2.194011 2.176459,-2.194011s2.176459,0.982917 2.176459,2.194011zm0.017552,3.94922l-4.388022,0l0,14.04167l4.388022,0l0,-14.04167zm7.005038,0l-4.359939,0l0,14.04167l4.360816,0l0,-7.370999c0,-4.098413 5.291077,-4.433657 5.291077,0l0,7.370999l4.377491,0l0,-8.89101c0,-6.915523 -7.829986,-6.66365 -9.669445,-3.259423l0,-1.891237z"/>
    
  </svg>
</i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>

<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/swift/">#Swift</a>



  
  | <a class="subtitle is-6" href="/tags/realitykit/">#RealityKit</a>
  


      
    </div>
    <h2 class="subtitle is-6">January 3, 2023</h2>
    <h1 class="title">Realitykit Surface Detection</h1>
    
    <div class="content">
      <p>I&rsquo;ve spent a lot of time learning and writing code based on RealityKit. I really like the framework. It&rsquo;s nicely written, has a lovely tiny, lightweight ECS implementation and makes writing AR applications and games pretty straightforward. I thought I&rsquo;d write down some things I&rsquo;ve learned in a series of blog posts that might help other AR devs out there in the wild.</p>
<p>The first thing that comes up when writing a new RealityKit app is detecting surfaces in order to anchor virtual objects in the real world. Adding anchors helps optimize world tracking accuracy so that virtual objects stay in place. RealityKit has several ways of doing this so I&rsquo;m going to start there. My first take on this will be to use the way ARKit uses anchors with ARAnchor and show how it relates to anchors like AnchorEntity in RealityKit. Basically we&rsquo;ll roll our own RealityKit AnchorEntity. Our created anchor will be an entity in the RealityKit Entity Component System (ECS). There are easier ways of doing this in RealityKit but understanding ARKit ARAnchors helped me to understand how anchoring works beneath all abstractions. This is the basic overview:</p>
<p><img src="/overview.png" alt="overview"></p>
<p>Starting from ARKit and moving into RealityKit makes easier to understand how RealityKit has evolved over time. In both ARKit and RealityKit we need an ARSession to start with. This ARSession coordinates all the processes that are needed to create an AR experience. Camera control, image analysis and tracking to name a few. The ARSession feeds data to the different renderers like the RealityKit ARView, SceneKit&rsquo;s ARSCNView or SpriteKit&rsquo;s ARSKView. As we&rsquo;re using RealityKit we&rsquo;ll stick to ARView.</p>
<p>In order to use ARViews from SwiftUI we need to wrap it in a UIViewRepresentable.</p>
<pre tabindex="0"><code>struct ARContainer: UIViewRepresentable {
    func makeUIView(context: Context) -&gt; DetectionView {
        let arView = DetectionView(frame: .zero)
        arView.setup()
        return arView
    }
    func updateUIView(_ uiView: DetectionView, context: Context) {}
}
</code></pre><p>In this case our custom created DetectionView inherits from ARView and is the view that will register as a delegate for the ARSession callbacks.</p>
<p>The ARSession also lets us know when it detects surfaces. We&rsquo;ll use those surfaces to create our anchors. The anchors we find will root our virtual objects in the real world.</p>
<pre tabindex="0"><code>/// Start ARSession and setup self as delegate.
private func setupARSession() {
       let session = self.session
       let configuration = ARWorldTrackingConfiguration()
       configuration.planeDetection = [.horizontal]
       session.run(configuration)
       session.delegate = self
   }
</code></pre><p>Every ARSession needs a configuration. In our example we&rsquo;ll specify that we&rsquo;re interested in horizontal surfaces. When the ARSession finds new surfaces we&rsquo;ll get a callback by registering as a delegate and use those new surfaces as anchors for virtual objects in our scene. We&rsquo;ll implement three methods from the ARSessionDelegate protocol to handle the callbacks.</p>
<pre tabindex="0"><code>func session(_ session: ARSession, didAdd anchors: [ARAnchor])
func session(_ session: ARSession, didUpdate anchors: [ARAnchor])
func session(_ session: ARSession, didRemove anchors: [ARAnchor])
</code></pre><p>When the running ARSession finds new horizontal surfaces it&rsquo;ll call the didAdd method with an array of found surfaces/anchors. We&rsquo;ll keep track of the anchors and also update them along the way. As the ARSession finds out more about the surrounding world it&rsquo;ll modify the anchors/surfaces, merging them, moving, rotating or in other ways adapt them as the session learns more about the surroundings. This is important to remember, they can change any time if we continue to run our ARSession. The update method will handle just that. In this method we&rsquo;ll recreate the visulizing surface mesh for the found anchors or in other ways adapt them to the current world understanding. Making them better align with the real world as we move along. The didRemove method handles removed surfaces, this could be a horizontal surface on a chair that has been moved to another location. In this case we&rsquo;ll remove the surface from our list and delete it.
<img src="/arch.png" alt="dictionary">
In our DetectionView we&rsquo;ll keep a dictionary with anchor identifiers provided by the ARAnchors in the callback as key and our custom made AnchorEntites as values. The Anchor entities will be used as anchor points in the RealityKit scene, will contain a Model/Mesh displaying the surface and they can host other ECS entities as child objects.</p>
<pre tabindex="0"><code>class DetectionView: ARView, ARSessionDelegate {
    /// Dictionary with id from the ARPlaneAnchor as key and a PlaneAnchorEntity as value
    var planes = [UUID: PlaneAnchorEntity]()
</code></pre><p>The callbacks will follow the same startup procedure, iterating through the provided ARAnchors, making sure they are a plane (ARPlaneAnchor) and not another type of anchor. If they aren&rsquo;t in the dictionary already, we&rsquo;ll add them to the dictionary and also add them to the scene anchors array. This is where we&rsquo;ll add our virtual object entities as children.</p>
<pre tabindex="0"><code>/// Anchors have been added. Add them to the dictionary and add PlaneAnchorEntities to the scene.
func session(_ session: ARSession, didAdd anchors: [ARAnchor]) {
    for anchor in anchors {
        if let arPlaneAnchor = anchor as? ARPlaneAnchor {
            let id = arPlaneAnchor.identifier
            if planes.contains(where: {$0.key == id}) { fatalError(&#34;anchor already exists&#34;)}
            let planeAnchorEntity = PlaneAnchorEntity(arPlaneAnchor: arPlaneAnchor)
            self.scene.anchors.append(planeAnchorEntity)
            planes[id] = planeAnchorEntity
        }
    }
}
</code></pre><p>One thing I absolutely love with RealityKit is that it favours composition over inheritance. This follows along nicely with the design of the Entity Component System so in most cases it&rsquo;s easier to support a protocol and add a component instead of inheriting from a super class. This is the case for HasModel. We make our PlaneAnchorEntity implement HasModel and add a ModelComponent in the constructor. The ModelComponent will display the plane mesh using an unlit transparent material. We&rsquo;ll also need to copy the transform matrix from the provided ARAnchor to the transform of our Entity in order to set the position of our visual surface. The transform needs an additional translation to adjust to the center of the surface, we do to this by adding the arPlaneAnchor.center vector. A thing that has changed in iOS16 that took me a while to figure out is that the provided transform matrix from the ARAnchor used to include the Y axis rotation. Starting with iOS16 this isn&rsquo;t the case anymore and we need to adjust the y axis rotation with the provided arPlaneAnchor.planeExtent.rotationOnYAxis value.</p>
<pre tabindex="0"><code>class PlaneAnchorEntity: Entity, HasModel, HasAnchoring {
    
    @available(*, unavailable)
    required init() {
        fatalError(&#34;Not available&#34;)
    }
    
    /// Initialize the AnchorEntity. Model is provided using a ModelComponent while HasAnchoring is implemented by updating transform and mesh directly from ARSession.
    /// Adjust position to center of plane and rotate on Y with provided angle from the Anchor planeExtent.
    init(arPlaneAnchor: ARPlaneAnchor) {
        super.init()
        self.components.set(createModelComponent(arPlaneAnchor))
        self.transform.matrix = arPlaneAnchor.transform
        self.position += arPlaneAnchor.center
        self.orientation = simd_quatf(angle: arPlaneAnchor.planeExtent.rotationOnYAxis, axis: [0,1,0])
    }
    
    /// Create a model compontent with a planemesh using the size of the provided ARPlaneAnchor.
    private func createModelComponent(_ arPlaneAnchor: ARPlaneAnchor) -&gt; ModelComponent {
        let mesh = MeshResource.generatePlane(width: arPlaneAnchor.planeExtent.width, depth: arPlaneAnchor.planeExtent.height)
        let material = UnlitMaterial(color: .lightGray.withAlphaComponent(0.5))
        let modelComponent = ModelComponent(mesh: mesh, materials: [material])
        return modelComponent
    }
    
    /// Called when the ARsession has updated the anchor. Update the transform and the mesh with provided transform/size.
    /// Adjust position to center of plane and rotate on Y with provided angle from the Anchor planeExtent.
    func didUpdate(arPlaneAnchor: ARPlaneAnchor) throws {
        self.model?.mesh = MeshResource.generatePlane(width: arPlaneAnchor.planeExtent.width, depth: arPlaneAnchor.planeExtent.height)
        self.transform.matrix = arPlaneAnchor.transform
        self.position += arPlaneAnchor.center
        self.orientation = simd_quatf(angle: arPlaneAnchor.planeExtent.rotationOnYAxis, axis: [0,1,0])
    }
}
</code></pre><p>The didUpdate function recreates the model surface mesh based on the provided ARAnchor plane size and follows the same pattern as described above. And that&rsquo;s it. We&rsquo;ve rolled our own RealityKit Archor entity that can be added to the Scenes anchors array. They can contain virtual objects as children and they also display a mesh using a ModelComponent. There are easier ways of doing anchors in RealityKit but they all use this underlying strategy behind the scenes so this helped me grok the anchor behaviors in RealityKit when I started out.</p>
<p><img src="/surface.gif" alt="app"></p>
<p>All code for this blog post is available <a href="https://github.com/deurell/SurfaceDetection">here</a>. Have an excellent AR dev day!</p>

      
    </div>
    
  </div>
</section>



<section class="section">
  <div class="container has-text-centered">
    <p></p>
    
  </div>
</section>





</body>
</html>

